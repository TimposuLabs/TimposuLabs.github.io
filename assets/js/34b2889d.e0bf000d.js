"use strict";(globalThis.webpackChunktimposu=globalThis.webpackChunktimposu||[]).push([[80689],{10691(e,a,n){n.r(a),n.d(a,{assets:()=>d,contentTitle:()=>l,default:()=>o,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"springboot/springboot-jpa-hibernate/eager-lazy","title":"Fetch Type: Eager vs Lazy","description":"Dalam Hibernate, Eager dan Lazy Fetching adalah strategi untuk mengambil/read data relasional dari database.","source":"@site/tutorial/spring/springboot/springboot-jpa-hibernate/16-eager-lazy.md","sourceDirName":"springboot/springboot-jpa-hibernate","slug":"/springboot/springboot-jpa-hibernate/eager-lazy","permalink":"/spring/springboot/springboot-jpa-hibernate/eager-lazy","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_position":16,"title":"Fetch Type: Eager vs Lazy"},"sidebar":"tutorialSidebar","previous":{"title":"One-to-Many Create","permalink":"/spring/springboot/springboot-jpa-hibernate/one-to-many-create"},"next":{"title":"One-to-Many Eager Fetch","permalink":"/spring/springboot/springboot-jpa-hibernate/one-to-many-eager"}}');var s=n(74848),t=n(28453);const r={sidebar_position:16,title:"Fetch Type: Eager vs Lazy"},l=void 0,d={},c=[{value:"1\ufe0f\u20e3 Lazy Fetching (Default untuk Collections)",id:"1\ufe0f\u20e3-lazy-fetching-default-untuk-collections",level:2},{value:"2\ufe0f\u20e3 Eager Fetching (Default untuk Single Object)",id:"2\ufe0f\u20e3-eager-fetching-default-untuk-single-object",level:2},{value:"3\ufe0f\u20e3 Perbandingan",id:"3\ufe0f\u20e3-perbandingan",level:2},{value:"4\ufe0f\u20e3 Default Fetch Type",id:"4\ufe0f\u20e3-default-fetch-type",level:2},{value:"5\ufe0f\u20e3 Rekomendasi Penggunaan",id:"5\ufe0f\u20e3-rekomendasi-penggunaan",level:2}];function h(e){const a={admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(a.p,{children:["Dalam Hibernate, ",(0,s.jsx)(a.strong,{children:"Eager"})," dan ",(0,s.jsx)(a.strong,{children:"Lazy"})," Fetching adalah strategi untuk mengambil/read data relasional dari database."]}),"\n",(0,s.jsx)(a.h2,{id:"1\ufe0f\u20e3-lazy-fetching-default-untuk-collections",children:"1\ufe0f\u20e3 Lazy Fetching (Default untuk Collections)"}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Lazy Fetching"}),' adalah strategi "tunda". Hibernate hanya akan mengambil data entity utama terlebih dahulu. Data relasi baru akan diambil dari database jika dan hanya jika kita memanggilnya (misalnya melalui method ',(0,s.jsx)(a.code,{children:"getter"}),")."]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Cara Kerja:"}),' Hibernate membuat objek "Proxy" (palsu). Query ',(0,s.jsx)(a.code,{children:"SELECT"})," tambahan hanya dijalankan jika data tersebut dipanggil."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Kelebihan:"})," Menghemat memori dan mempercepat beban awal objek utama."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Kekurangan:"})," Berisiko menyebabkan ",(0,s.jsx)(a.code,{children:"LazyInitializationException"})," jika data diakses setelah ",(0,s.jsx)(a.em,{children:"Session"})," ditutup. Juga dapat memicu masalah ",(0,s.jsx)(a.strong,{children:"N+1 Query"}),"."]}),"\n"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'@OneToMany(mappedBy = "classes", fetch = FetchType.LAZY)\nList<Student> students = new ArrayList<>();\n'})}),"\n",(0,s.jsx)(a.h2,{id:"2\ufe0f\u20e3-eager-fetching-default-untuk-single-object",children:"2\ufe0f\u20e3 Eager Fetching (Default untuk Single Object)"}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"Eager Fetching"})," adalah strategi di mana Hibernate akan mengambil entity utama beserta seluruh entity yang berelasi dengannya secara langsung dalam satu waktu (biasanya menggunakan ",(0,s.jsx)(a.code,{children:"JOIN"}),")."]}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Cara Kerja:"})," Saat kita mengambil objek utama, Hibernate otomatis mengambil semua data relasinya."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Kelebihan:"})," Data selalu tersedia, tidak ada risiko ",(0,s.jsx)(a.code,{children:"LazyInitializationException"}),"."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Kekurangan:"})," Performa menurun jika data relasi sangat besar atau banyak, karena query menjadi sangat berat."]}),"\n"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'@ManyToOne(fetch = FetchType.EAGER)\n@JoinColumn(name = "class_id")\nprivate Classes classes;\n'})}),"\n",(0,s.jsx)(a.h2,{id:"3\ufe0f\u20e3-perbandingan",children:"3\ufe0f\u20e3 Perbandingan"}),"\n",(0,s.jsxs)(a.table,{children:[(0,s.jsx)(a.thead,{children:(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.th,{children:"Fitur"}),(0,s.jsx)(a.th,{children:"Lazy Fetching"}),(0,s.jsx)(a.th,{children:"Eager Fetching"})]})}),(0,s.jsxs)(a.tbody,{children:[(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"Waktu Load"})}),(0,s.jsxs)(a.td,{children:["Saat data dibutuhkan (",(0,s.jsx)(a.em,{children:"On-demand"}),")"]}),(0,s.jsxs)(a.td,{children:["Langsung (",(0,s.jsx)(a.em,{children:"Initial load"}),")"]})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"Performa"})}),(0,s.jsx)(a.td,{children:"Lebih efisien untuk data besar"}),(0,s.jsx)(a.td,{children:"Lebih lambat jika relasi banyak"})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"Default"})}),(0,s.jsxs)(a.td,{children:[(0,s.jsx)(a.code,{children:"@OneToMany"}),", ",(0,s.jsx)(a.code,{children:"@ManyToMany"})]}),(0,s.jsxs)(a.td,{children:[(0,s.jsx)(a.code,{children:"@ManyToOne"}),", ",(0,s.jsx)(a.code,{children:"@OneToOne"})]})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"Metode Query"})}),(0,s.jsxs)(a.td,{children:[(0,s.jsx)(a.em,{children:"Multiple queries"})," (kecuali di-join)"]}),(0,s.jsxs)(a.td,{children:[(0,s.jsx)(a.em,{children:"Single query"})," dengan JOIN"]})]})]})]}),"\n",(0,s.jsx)(a.h2,{id:"4\ufe0f\u20e3-default-fetch-type",children:"4\ufe0f\u20e3 Default Fetch Type"}),"\n",(0,s.jsxs)(a.table,{children:[(0,s.jsx)(a.thead,{children:(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.th,{children:"Tipe Relasi"}),(0,s.jsx)(a.th,{children:"Default Fetch Type"}),(0,s.jsx)(a.th,{children:"Penjelasan"})]})}),(0,s.jsxs)(a.tbody,{children:[(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.code,{children:"@ManyToOne"})}),(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"EAGER"})}),(0,s.jsxs)(a.td,{children:["Saat mengambil data anak/child (contoh: ",(0,s.jsx)(a.code,{children:"Student"}),"), data induk (contoh: ",(0,s.jsx)(a.code,{children:"Classes"}),") otomatis ikut diambil."]})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.code,{children:"@OneToOne"})}),(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"EAGER"})}),(0,s.jsx)(a.td,{children:"Saat mengambil entity utama, entity yang berelasi 1-ke-1 langsung ikut dimuat."})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.code,{children:"@OneToMany"})}),(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"LAZY"})}),(0,s.jsxs)(a.td,{children:["Koleksi data anak/child tidak akan dimuat sampai Anda memanggil metode ",(0,s.jsx)(a.code,{children:".getStudents()"}),"."]})]}),(0,s.jsxs)(a.tr,{children:[(0,s.jsx)(a.td,{children:(0,s.jsx)(a.code,{children:"@ManyToMany"})}),(0,s.jsx)(a.td,{children:(0,s.jsx)(a.strong,{children:"LAZY"})}),(0,s.jsx)(a.td,{children:"Karena potensi data yang sangat besar, Hibernate tidak akan memuat relasi ini secara otomatis."})]})]})]}),"\n",(0,s.jsx)(a.h2,{id:"5\ufe0f\u20e3-rekomendasi-penggunaan",children:"5\ufe0f\u20e3 Rekomendasi Penggunaan"}),"\n",(0,s.jsxs)(a.ol,{children:["\n",(0,s.jsxs)(a.li,{children:["Gunakan ",(0,s.jsx)(a.strong,{children:"Lazy"})," secara default untuk hampir semua relasi guna menjaga performa aplikasi."]}),"\n",(0,s.jsxs)(a.li,{children:["Gunakan ",(0,s.jsx)(a.strong,{children:"Eager"})," hanya jika Anda yakin 100% bahwa data relasi tersebut akan selalu digunakan setiap kali objek utama dipanggil."]}),"\n",(0,s.jsxs)(a.li,{children:["Untuk mengatasi masalah performa pada Lazy, gunakan ",(0,s.jsx)(a.strong,{children:"Join Fetch"})," dalam query HQL/JPQL agar data diambil secara selektif dalam satu query."]}),"\n"]}),"\n",(0,s.jsxs)(a.admonition,{type:"tip",children:[(0,s.jsx)(a.p,{children:(0,s.jsx)(a.strong,{children:"Cara Menghapal:"})}),(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:['Relasi yang berakhiran "',(0,s.jsx)(a.strong,{children:"...ToOne"}),'" secara default adalah ',(0,s.jsx)(a.strong,{children:"EAGER"}),"."]}),"\n",(0,s.jsxs)(a.li,{children:['Relasi yang berakhiran "',(0,s.jsx)(a.strong,{children:"...ToMany"}),'" secara default adalah ',(0,s.jsx)(a.strong,{children:"LAZY"}),"."]}),"\n"]})]}),"\n",(0,s.jsxs)(a.admonition,{type:"info",children:[(0,s.jsxs)(a.p,{children:["Dalam Hibernate/JPA, ",(0,s.jsx)(a.strong,{children:"Join Fetch"})," adalah teknik query yang digunakan untuk mengambil entity utama beserta entity relasinya (anak-anaknya) dalam ",(0,s.jsx)(a.strong,{children:"satu kali perintah SQL SELECT"}),"."]}),(0,s.jsxs)(a.p,{children:["Tujuan utamanya adalah untuk mengatasi masalah performa yang dikenal sebagai ",(0,s.jsx)(a.strong,{children:"N+1 Select Problem"}),"."]}),(0,s.jsx)(a.p,{children:"Berikut penjelasan mendalamnya:"}),(0,s.jsx)(a.p,{children:(0,s.jsx)(a.strong,{children:"1. Masalah: N+1 Select Problem (Tanpa Fetch)"})}),(0,s.jsxs)(a.p,{children:["Secara default, relasi seperti ",(0,s.jsx)(a.code,{children:"@OneToMany"})," bersifat ",(0,s.jsx)(a.strong,{children:"LAZY"}),"."]}),(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Query 1"}),": Mengambil data Kelas (",(0,s.jsx)(a.code,{children:"SELECT * FROM classes"}),")."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Query N"}),": Saat melakukan loop untuk melihat siswa di setiap kelas, Hibernate akan menjalankan query baru untuk ",(0,s.jsx)(a.strong,{children:"setiap"})," kelas (",(0,s.jsx)(a.code,{children:"SELECT * FROM student WHERE class_id = ?"}),")."]}),"\n",(0,s.jsxs)(a.li,{children:[(0,s.jsx)(a.strong,{children:"Hasilnya"}),": Jika ada 100 kelas, maka akan menjalankan 1 + 100 query. Ini sangat lambat."]}),"\n"]}),(0,s.jsx)(a.p,{children:(0,s.jsx)(a.strong,{children:"2. Solusi: Join Fetch"})}),(0,s.jsxs)(a.p,{children:["Dengan menggunakan ",(0,s.jsx)(a.code,{children:"JOIN FETCH"})," dalam HQL (",(0,s.jsx)(a.em,{children:"Hibernate Query Language"}),"), Hibernate akan melakukan ",(0,s.jsx)(a.strong,{children:"SQL JOIN"})," dan langsung mengisi semua data ke dalam objek Java dalam satu kali jalan (1 query)."]}),(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-java",children:'// Mengambil Kelas DAN Siswanya sekaligus dalam 1 query\nString hql = "SELECT c FROM Classes c JOIN FETCH c.students WHERE c.id = :id";\nClasses tempClass = session.createQuery(hql, Classes.class)\n                           .setParameter("id", 1)\n                           .getSingleResult();\n'})})]})]})}function o(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453(e,a,n){n.d(a,{R:()=>r,x:()=>l});var i=n(96540);const s={},t=i.createContext(s);function r(e){const a=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(t.Provider,{value:a},e.children)}}}]);