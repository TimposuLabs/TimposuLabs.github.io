"use strict";(globalThis.webpackChunktimposu=globalThis.webpackChunktimposu||[]).push([[5561],{28453(e,n,a){a.d(n,{R:()=>r,x:()=>d});var s=a(96540);const i={},t=s.createContext(i);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(t.Provider,{value:n},e.children)}},38869(e,n,a){a.d(n,{A:()=>s});const s=a.p+"assets/images/one-to-many-9b0c1b7dcb970cfe0651f52fbee15133.png"},40963(e,n,a){a.d(n,{A:()=>s});const s=a.p+"assets/images/one-to-many2-00fb2d0cbe6ed69f3fb5b85aae37a8e9.png"},45058(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"springboot/springboot-jpa-hibernate/one-to-many","title":"One-to-Many Mapping","description":"1\ufe0f\u20e3 Konsep Dasar","source":"@site/tutorial/spring/springboot/springboot-jpa-hibernate/14-one-to-many.md","sourceDirName":"springboot/springboot-jpa-hibernate","slug":"/springboot/springboot-jpa-hibernate/one-to-many","permalink":"/spring/springboot/springboot-jpa-hibernate/one-to-many","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"sidebar_position":14,"title":"One-to-Many Mapping"},"sidebar":"tutorialSidebar","previous":{"title":"One-to-One Cascade","permalink":"/spring/springboot/springboot-jpa-hibernate/one-to-one-cascade"},"next":{"title":"One-to-Many Create","permalink":"/spring/springboot/springboot-jpa-hibernate/one-to-many-create"}}');var i=a(74848),t=a(28453);const r={sidebar_position:14,title:"One-to-Many Mapping"},d=void 0,l={},o=[{value:"1\ufe0f\u20e3 Konsep Dasar",id:"1\ufe0f\u20e3-konsep-dasar",level:2},{value:"2\ufe0f\u20e3 Implementasi Entity (Bi-Directional)",id:"2\ufe0f\u20e3-implementasi-entity-bi-directional",level:2},{value:"A. Entity Student (Sisi &quot;Many&quot; / Owner)",id:"a-entity-student-sisi-many--owner",level:3},{value:"B. Entity Classes (Sisi &quot;One&quot; / Inverse)",id:"b-entity-classes-sisi-one--inverse",level:3},{value:"C. Kenapa <code>Classes</code> yang menggunakan <code>mappedBy</code>?",id:"c-kenapa-classes-yang-menggunakan-mappedby",level:3},{value:"3\ufe0f\u20e3 Poin Penting",id:"3\ufe0f\u20e3-poin-penting",level:2}];function c(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"1\ufe0f\u20e3-konsep-dasar",children:"1\ufe0f\u20e3 Konsep Dasar"}),"\n",(0,i.jsxs)(n.p,{children:["Relasi ",(0,i.jsx)(n.strong,{children:"One-to-Many"})," berarti satu baris di tabel utama berhubungan dengan banyak baris di tabel lain."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Contoh:"})," Satu ",(0,i.jsx)(n.strong,{children:"Kelas"})," (",(0,i.jsx)(n.code,{children:"Classes"}),") memiliki banyak ",(0,i.jsx)(n.strong,{children:"Siswa"})," (",(0,i.jsx)(n.code,{children:"Student"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Foreign Key (FK) \ud83d\udd11"}),": Secara fisik di database, kolom FK (",(0,i.jsx)(n.code,{children:"class_id"}),') selalu diletakkan di sisi "Banyak/Many" yaitu tabel ',(0,i.jsx)(n.strong,{children:"student"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"2\ufe0f\u20e3-implementasi-entity-bi-directional",children:"2\ufe0f\u20e3 Implementasi Entity (Bi-Directional)"}),"\n",(0,i.jsxs)(n.p,{children:["Dalam relasi dua arah, kedua class saling mengenal. Kita menggunakan atribut ",(0,i.jsx)(n.code,{children:"mappedBy"}),' di sisi "One" agar Hibernate tahu bahwa relasi diatur oleh field di sisi "Many".']}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Hibernate",src:a(38869).A+"",width:"552",height:"333"})}),"\n",(0,i.jsx)(n.h3,{id:"a-entity-student-sisi-many--owner",children:'A. Entity Student (Sisi "Many" / Owner)'}),"\n",(0,i.jsxs)(n.p,{children:["Sisi ini yang memegang ",(0,i.jsx)(n.code,{children:"@JoinColumn"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Entity\r\n@Table(name = "student")\r\npublic class Student {\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\r\n\tprivate Integer id;\r\n\t\r\n\t@Column(name = "first_name")\r\n\tprivate String firstName;\r\n\t\r\n\t@Column(name = "last_name")\r\n\tprivate String lastName;\r\n\t\r\n\t@ManyToOne(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})\r\n\t@JoinColumn(name = "class_id")\r\n\tprivate Classes classes;\r\n\r\n\t// Setter & Getter\r\n\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"b-entity-classes-sisi-one--inverse",children:'B. Entity Classes (Sisi "One" / Inverse)'}),"\n",(0,i.jsxs)(n.p,{children:["Sisi ini menggunakan ",(0,i.jsx)(n.code,{children:"mappedBy"})," dan memiliki koleksi (",(0,i.jsx)(n.code,{children:"List"})," atau ",(0,i.jsx)(n.code,{children:"Set"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'@Entity\r\n@Table(name = "classes")\r\npublic class Classes {\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\r\n\tprivate Integer id;\r\n\t\r\n\t@Column(name = "class_name")\r\n\tprivate String className;\r\n\t\r\n\t@OneToOne(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})\r\n\t@JoinColumn(name = "teacher_id")\r\n\tprivate Teacher teacher;\r\n\t\r\n\t@OneToMany(mappedBy = "classes", cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})\r\n\tList<Student> students = new ArrayList<>();\r\n\r\n\r\n\t// HELPER METHOD: Sangat penting untuk sinkronisasi 2 arah di memori\r\n\t// menambah method \'add()\' memastikan kedua sisi terhubung secara konsisten dalam memori Java dengan Bi-Direction\r\n\tpublic void add(Student student) {\r\n\t\tif (students == null) {\r\n\t\t\tstudents = new ArrayList<>();\t\t\t\r\n\t\t}\r\n\t\tstudents.add(student);\r\n\t\t\r\n\t\tif (student != null) {\r\n\t\t\tstudent.setClasses(this);\r\n\t\t}\r\n\t}\r\n\r\n\t// Setter & Getter\r\n\r\n}\n'})}),"\n",(0,i.jsxs)(n.h3,{id:"c-kenapa-classes-yang-menggunakan-mappedby",children:["C. Kenapa ",(0,i.jsx)(n.code,{children:"Classes"})," yang menggunakan ",(0,i.jsx)(n.code,{children:"mappedBy"}),"?"]}),"\n",(0,i.jsxs)(n.p,{children:["Dalam aturan database relasional, ",(0,i.jsx)(n.code,{children:"Foreign Key"}),' (kolom kunci) selalu diletakkan di tabel yang "Banyak/Many" (',(0,i.jsx)(n.code,{children:"Student"}),"). Karena tabel ",(0,i.jsx)(n.code,{children:"Student"})," yang memegang kunci fisik di database, maka dalam kode Java:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Student"})," disebut sebagai ",(0,i.jsx)(n.strong,{children:"Owner"})," (Pemilik Relasi)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Classes"})," disebut sebagai ",(0,i.jsx)(n.strong,{children:"Inverse Side"})," (Sisi Referensi), sehingga ia harus menggunakan ",(0,i.jsx)(n.code,{children:"mappedBy"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["Ringkasan Aturan ",(0,i.jsx)(n.code,{children:"mappedBy"})]})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Posisi"}),(0,i.jsx)(n.th,{children:"Entitas"}),(0,i.jsxs)(n.th,{children:["Anotasi\tMenggunakan ",(0,i.jsx)(n.code,{children:"mappedBy"}),"?"]}),(0,i.jsx)(n.th,{children:"Keterangan"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"One"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Classes"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@OneToMany"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Ya"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Many"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"Student"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@ManyToOne"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Tidak"})})]})]})]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inisialisasi List :"})," Selalu inisialisasi ",(0,i.jsx)(n.code,{children:"List<Student> students = new ArrayList<>();"})," di sisi ",(0,i.jsx)(n.code,{children:"Classes"})," untuk menghindari ",(0,i.jsx)(n.code,{children:"NullPointerException"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Helper Method :"})," Disarankan membuat method ",(0,i.jsx)(n.code,{children:"addStudent(Student s)"})," di dalam entity ",(0,i.jsx)(n.code,{children:"Classes"})," untuk memastikan kedua sisi terhubung secara konsisten dalam memori Java sebelum disimpan ke database menggunakan Spring Data JPA."]}),"\n"]})}),"\n",(0,i.jsx)(n.p,{children:"Jika dijalankan akan menghasilkan 2 tabel yang saling terhubung:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Hibernate: alter table student add column class_id integer\r\nHibernate: alter table student add constraint FKnsl7w2nw6o6eq53hqlxfcijpm foreign key (class_id) references classes (id)\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Hibernate",src:a(40963).A+"",width:"782",height:"310"})}),"\n",(0,i.jsx)(n.h2,{id:"3\ufe0f\u20e3-poin-penting",children:"3\ufe0f\u20e3 Poin Penting"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Lazy vs Eager Fetching"}),": Secara default, ",(0,i.jsx)(n.code,{children:"@OneToMany"})," bersifat ",(0,i.jsx)(n.strong,{children:"Lazy"}),". Artinya, data siswa tidak akan ditarik dari DB kecuali Anda memanggil ",(0,i.jsx)(n.code,{children:"getStudents()"}),". Jika Anda mencoba mengakses data ini setelah ",(0,i.jsx)(n.code,{children:"session.close()"}),", akan terjadi ",(0,i.jsx)(n.code,{children:"LazyInitializationException"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"mappedBy"})}),": Atribut ini sangat krusial. Ini akan memberitahu Hibernate bahwa sisi ",(0,i.jsx)(n.code,{children:"Classes"}),' hanyalah "mirror". Pemilik sebenarnya dari relasi ini adalah sisi ',(0,i.jsx)(n.code,{children:"Student"})," (yang memegang FK)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Orphan Removal"}),": Jika Anda menambahkan ",(0,i.jsx)(n.code,{children:"orphanRemoval = true"})," pada ",(0,i.jsx)(n.code,{children:"@OneToMany"}),", maka saat Anda menghapus seorang siswa dari ",(0,i.jsx)(n.code,{children:"List<Student>"}),", Hibernate akan otomatis menghapus siswa tersebut dari database (bukan hanya mengosongkan FK-nya)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inisialisasi List"}),": Selalu inisialisasi ",(0,i.jsx)(n.code,{children:"List"})," dengan ",(0,i.jsx)(n.code,{children:"new ArrayList<>()"})," untuk menghindari ",(0,i.jsx)(n.code,{children:"NullPointerException"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);