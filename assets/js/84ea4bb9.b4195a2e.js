"use strict";(globalThis.webpackChunktimposu=globalThis.webpackChunktimposu||[]).push([[9288],{28453(a,n,e){e.d(n,{R:()=>l,x:()=>c});var i=e(96540);const t={},r=i.createContext(t);function l(a){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof a?a(n):{...n,...a}},[n,a])}function c(a){let n;return n=a.disableParentContext?"function"==typeof a.components?a.components(t):a.components||t:l(a.components),i.createElement(r.Provider,{value:n},a.children)}},83498(a,n,e){e.r(n),e.d(n,{assets:()=>s,contentTitle:()=>c,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"java-collection/legacy-collection","title":"Legacy Collection","description":"Collection sudah ada sejak Java versi 1, namun seiring waktu, Java Collection semakin berkembang. Sebenarnya ada beberapa legacy collection (collection jadul) yang belum kita bahas, namun jarang sekali digunakan sekarang ini:","source":"@site/tutorial/java/java-collection/17-legacy-collection.md","sourceDirName":"java-collection","slug":"/java-collection/legacy-collection","permalink":"/java/java-collection/legacy-collection","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":17,"frontMatter":{"sidebar_position":17,"title":"Legacy Collection"},"sidebar":"tutorialSidebar","previous":{"title":"Java EntryMap","permalink":"/java/java-collection/entrymap"},"next":{"title":"Sorting Collection","permalink":"/java/java-collection/sorting-collection"}}');var t=e(74848),r=e(28453);const l={sidebar_position:17,title:"Legacy Collection"},c=void 0,s={},o=[{value:"Vector",id:"vector",level:2},{value:"HashTable",id:"hashtable",level:2},{value:"Stack",id:"stack",level:2}];function d(a){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...a.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Collection sudah ada sejak Java versi 1, namun seiring waktu, Java Collection semakin berkembang. Sebenarnya ada beberapa legacy collection (collection jadul) yang belum kita bahas, namun jarang sekali digunakan sekarang ini:"}),"\n",(0,t.jsx)(n.h2,{id:"vector",children:"Vector"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Vector"})," class adalah implementasi dari interface ",(0,t.jsx)(n.code,{children:"List"}),". Cara kerja ",(0,t.jsx)(n.code,{children:"Vector"})," mirip dengan ",(0,t.jsx)(n.code,{children:"ArrayList"}),", yang membedakan adalah semua method di Vector menggunakan kata kunci  synchronized yang artinya dia thread safe. Namun problemnya adalah, karena semua method menggunakan kata kunci synchronized, secara otomatis impact nya ke-performance yang menjadi lambat dibandingkan menggunakan ",(0,t.jsx)(n.code,{children:"ArrayList"}),". Lalu bagaimana jika kita ingin membuat List yang bisa digunakan di proses paralel? Di versi Java baru, sudah disediakan yang lebih canggih untuk itu, oleh karena itu penggunakan Vector sudah jarang sekali ditemui sekarang."]}),"\n",(0,t.jsxs)(n.p,{children:["Contoh ",(0,t.jsx)(n.code,{children:"Vector"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Vector\r\nList<String> list = new Vector<String>();\r\nlist.add("Aco");\r\nlist.add("Dini");\r\nlist.add("Mike");\r\n\r\nfor (var name : list) {\r\n\tSystem.out.println(name);\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"hashtable",children:"HashTable"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"HashTable"})," adalah implementasi dari ",(0,t.jsx)(n.code,{children:"Map"})," yang mirip dengan ",(0,t.jsx)(n.code,{children:"HashMap"}),". Sama seperti ",(0,t.jsx)(n.code,{children:"Vector"}),", semua method di ",(0,t.jsx)(n.code,{children:"HashTable"})," memiliki kata kunci synchronized, sehingga performanya lebih lambat dibandingkan ",(0,t.jsx)(n.code,{children:"HashMap"}),", dan karena di versi Java baru sudah ada juga ",(0,t.jsx)(n.code,{children:"ConcurrentHashMap"}),", sehingga penggunaan ",(0,t.jsx)(n.code,{children:"HashTable"})," sudah jarang sekali ditemui."]}),"\n",(0,t.jsx)(n.p,{children:"Contoh:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// HashTable\r\nMap<String, String> map = new Hashtable<String, String>();\r\nmap.put("ph", "Philiphina");\r\nmap.put("vn", "Vietnam");\r\nmap.put("my", "Malaysia");\r\n\r\nfor (var m : map.keySet()) {\r\n\tSystem.out.println(m);\r\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"stack",children:"Stack"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Stack"})," adalah implementasi struktur data tumpukan LIFO (Last In First Out). Namun fitur yang lebih komplit dan konsisten sudah disediakan di ",(0,t.jsx)(n.code,{children:"Deque"}),", jadi tidak ada alasan lagi menggunakan class ",(0,t.jsx)(n.code,{children:"Stack"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Contoh:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Stack\r\nStack<String> stack = new Stack<String>();\r\nstack.push("Dandi");\r\nstack.push("Sultan");\r\nstack.push("Fahmi");\r\n\r\n// Error: stack.pop() akan menimbulkan exception EmptyStackException jika stack 0\r\nfor (var value = stack.pop() ; value != null ; value = stack.pop()) {\r\n\tSystem.out.println(value); \r\n}\n'})})]})}function u(a={}){const{wrapper:n}={...(0,r.R)(),...a.components};return n?(0,t.jsx)(n,{...a,children:(0,t.jsx)(d,{...a})}):d(a)}}}]);